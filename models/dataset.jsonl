{"instruction": "fly to waypoint_a", "output": "F(at(waypoint_a))"}
{"instruction": "go to waypoint_b", "output": "F(at(waypoint_b))"}
{"instruction": "navigate to waypoint_c", "output": "F(at(waypoint_c))"}
{"instruction": "proceed to landing_pad", "output": "F(at(landing_pad))"}
{"instruction": "move to waypoint_a", "output": "F(at(waypoint_a))"}
{"instruction": "head to waypoint_b", "output": "F(at(waypoint_b))"}
{"instruction": "travel to waypoint_c", "output": "F(at(waypoint_c))"}
{"instruction": "approach landing_pad", "output": "F(at(landing_pad))"}

{"instruction": "hover at waypoint_a for 10 seconds", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & hover(10))"}
{"instruction": "wait at waypoint_b for 5 seconds", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & hover(5))"}
{"instruction": "hover for 30 seconds at waypoint_c", "output": "F(at(waypoint_c)) & F(F(at(waypoint_c)) & hover(30))"}
{"instruction": "pause at landing_pad for 15 seconds", "output": "F(at(landing_pad)) & F(F(at(landing_pad)) & hover(15))"}

{"instruction": "fly above 2 meters", "output": "F(above(2.0))"}
{"instruction": "maintain altitude above 1.5 meters", "output": "G(above(1.5))"}
{"instruction": "stay above 1 meter altitude", "output": "G(above(1.0))"}
{"instruction": "climb above 2.5 meters", "output": "F(above(2.5))"}
{"instruction": "always stay above 0.5 meters", "output": "G(above(0.5))"}

{"instruction": "scan area_1", "output": "F(scan(area_1))"}
{"instruction": "perform scan of area_1", "output": "F(scan(area_1))"}
{"instruction": "inspect area_1", "output": "F(scan(area_1))"}
{"instruction": "survey area_1", "output": "F(scan(area_1))"}

{"instruction": "land at landing_pad", "output": "F(at(landing_pad)) & F(land())"}
{"instruction": "perform emergency return", "output": "F(emergency_return())"}
{"instruction": "return to base immediately", "output": "F(emergency_return())"}
{"instruction": "emergency landing", "output": "F(land())"}

{"instruction": "go to waypoint_a then waypoint_b", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(waypoint_b)))"}
{"instruction": "fly to waypoint_b then waypoint_c", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(waypoint_c)))"}
{"instruction": "visit waypoint_a then return to landing_pad", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(landing_pad)))"}
{"instruction": "go to waypoint_c then waypoint_a", "output": "F(at(waypoint_c)) & F(F(at(waypoint_c)) & F(at(waypoint_a)))"}

{"instruction": "first go to waypoint_a, then hover for 10 seconds, then continue to waypoint_b", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & hover(10) & F(F(hover(10)) & F(at(waypoint_b))))"}
{"instruction": "visit waypoint_b, wait 5 seconds, then proceed to waypoint_c", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & hover(5) & F(F(hover(5)) & F(at(waypoint_c))))"}
{"instruction": "go to waypoint_c, hover for 15 seconds, then return to base", "output": "F(at(waypoint_c)) & F(F(at(waypoint_c)) & hover(15) & F(F(hover(15)) & F(at(landing_pad))))"}

{"instruction": "always maintain altitude above 1 meter while going to waypoint_a", "output": "G(above(1.0)) & F(at(waypoint_a))"}
{"instruction": "stay above 2 meters until reaching waypoint_b", "output": "above(2.0) U at(waypoint_b)"}
{"instruction": "keep altitude above 1.5 meters while moving to waypoint_c", "output": "G(above(1.5)) & F(at(waypoint_c))"}
{"instruction": "maintain minimum 0.8 meter altitude until at landing_pad", "output": "above(0.8) U at(landing_pad)"}

{"instruction": "patrol between waypoint_a and waypoint_b", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b)))"}
{"instruction": "alternate between waypoint_b and waypoint_c", "output": "G(F(at(waypoint_b)) & F(at(waypoint_c)))"}
{"instruction": "continuously patrol waypoint_a to waypoint_c", "output": "G(F(at(waypoint_a)) & F(at(waypoint_c)))"}
{"instruction": "keep patrolling between landing_pad and waypoint_a", "output": "G(F(at(landing_pad)) & F(at(waypoint_a)))"}

{"instruction": "go to waypoint_a and scan area_1", "output": "F(at(waypoint_a)) & F(scan(area_1))"}
{"instruction": "visit waypoint_b then scan area_1", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(scan(area_1)))"}
{"instruction": "scan area_1 then return to landing_pad", "output": "F(scan(area_1)) & F(F(scan(area_1)) & F(at(landing_pad)))"}
{"instruction": "fly to waypoint_c and perform area scan", "output": "F(at(waypoint_c)) & F(scan(area_1))"}

{"instruction": "circle around waypoint_a maintaining 2 meter distance", "output": "G(near(waypoint_a, 2.0))"}
{"instruction": "stay within 1.5 meters of waypoint_b", "output": "G(near(waypoint_b, 1.5))"}
{"instruction": "maintain 3 meter radius around waypoint_c", "output": "G(near(waypoint_c, 3.0))"}
{"instruction": "orbit waypoint_a at 1 meter distance", "output": "G(near(waypoint_a, 1.0))"}

{"instruction": "if battery drops below 30%, return to base immediately", "output": "G(battery_level(30) -> F(at(landing_pad)))"}
{"instruction": "when battery reaches 25%, perform emergency return", "output": "G(battery_level(25) -> F(emergency_return()))"}
{"instruction": "emergency land if battery below 15%", "output": "G(battery_level(15) -> F(land()))"}
{"instruction": "return home when battery hits 20%", "output": "G(battery_level(20) -> F(at(landing_pad)))"}

{"instruction": "visit all waypoints then return home", "output": "F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c)) & F(F(at(waypoint_c)) & F(at(landing_pad)))"}
{"instruction": "tour waypoint_a, waypoint_b, waypoint_c in sequence", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(waypoint_b))) & F(F(at(waypoint_b)) & F(at(waypoint_c)))"}
{"instruction": "sequential visit: waypoint_b, waypoint_c, then waypoint_a", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(waypoint_c))) & F(F(at(waypoint_c)) & F(at(waypoint_a)))"}

{"instruction": "search pattern: scan area_1 then if target found, hover and signal", "output": "F(scan(area_1)) & G(target_detected() -> hover(30))"}
{"instruction": "systematic area scan then return to base", "output": "F(scan(area_1)) & F(F(scan(area_1)) & F(at(landing_pad)))"}
{"instruction": "perform surveillance sweep of area_1", "output": "F(scan(area_1))"}

{"instruction": "only scan area_1 if altitude is above 2 meters", "output": "G(scan(area_1) -> above(2.0))"}
{"instruction": "scan area_1 only when above 1.5 meters", "output": "G(scan(area_1) -> above(1.5))"}
{"instruction": "conditional scan: area_1 if above safe altitude", "output": "G(scan(area_1) -> above(1.0))"}

{"instruction": "approach waypoint_a from above 2 meters", "output": "F(above(2.0) & near(waypoint_a, 1.0)) & F(F(above(2.0) & near(waypoint_a, 1.0)) & F(at(waypoint_a)))"}
{"instruction": "descend to waypoint_b from high altitude", "output": "F(above(2.5)) & F(F(above(2.5)) & F(at(waypoint_b)))"}
{"instruction": "high approach to waypoint_c then land", "output": "F(above(2.0) & near(waypoint_c, 1.0)) & F(F(above(2.0) & near(waypoint_c, 1.0)) & F(at(waypoint_c)) & F(land()))"}

{"instruction": "go to waypoint_a, then return to it after visiting waypoint_b", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(waypoint_a))))"}
{"instruction": "visit waypoint_b, then go elsewhere, then come back to waypoint_b", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(waypoint_c)) & F(F(at(waypoint_c)) & F(at(waypoint_b))))"}
{"instruction": "round trip: waypoint_a to waypoint_c and back", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(waypoint_c)) & F(F(at(waypoint_c)) & F(at(waypoint_a))))"}

{"instruction": "check out area_1", "output": "F(near(area_1, 1.0)) & F(scan(area_1))"}
{"instruction": "inspect the area around waypoint_a", "output": "F(near(waypoint_a, 2.0)) & F(scan(area_1))"}
{"instruction": "investigate area_1 thoroughly", "output": "F(scan(area_1)) & G(near(area_1, 2.0))"}
{"instruction": "make sure everything is clear around waypoint_b", "output": "F(near(waypoint_b, 2.0)) & F(scan(area_1))"}

{"instruction": "do a quick flyby of waypoint_a", "output": "F(at(waypoint_a)) & F(X(!at(waypoint_a)))"}
{"instruction": "brief visit to waypoint_b", "output": "F(at(waypoint_b)) & F(X(!at(waypoint_b)))"}
{"instruction": "touch and go at waypoint_c", "output": "F(at(waypoint_c)) & F(X(!at(waypoint_c)))"}

{"instruction": "stay within the flight zone no matter what", "output": "G(in_bounds())"}
{"instruction": "never fly below minimum safe altitude", "output": "G(above(0.3))"}
{"instruction": "always maintain clearance from obstacles", "output": "G(clear_of(obstacles))"}
{"instruction": "remain within designated area at all times", "output": "G(in_bounds())"}

{"instruction": "if sensors detect obstacle, immediately climb to safe altitude", "output": "G(obstacle_detected() -> F(above(3.0)))"}
{"instruction": "climb if obstacle detected nearby", "output": "G(obstacle_detected() -> F(above(2.5)))"}
{"instruction": "emergency altitude gain on obstacle detection", "output": "G(obstacle_detected() -> F(above(3.0)))"}

{"instruction": "return to base if communication is lost", "output": "G(!communication() -> F(at(landing_pad)))"}
{"instruction": "emergency return on communication failure", "output": "G(!communication() -> F(emergency_return()))"}
{"instruction": "go home if signal lost", "output": "G(!communication() -> F(at(landing_pad)))"}

{"instruction": "never move but visit all waypoints", "output": "INVALID_SYNTAX: Contradictory requirements"}
{"instruction": "always stay at waypoint_a and always stay at waypoint_b", "output": "INVALID_SYNTAX: Contradictory spatial requirements"}
{"instruction": "be stationary while moving to waypoint_c", "output": "INVALID_SYNTAX: Contradictory motion requirements"}

{"instruction": "fly to unknown_waypoint_xyz", "output": "INVALID_SYNTAX: Unknown waypoint"}
{"instruction": "go to nonexistent_location", "output": "INVALID_SYNTAX: Unknown waypoint"}
{"instruction": "navigate to mystery_point", "output": "INVALID_SYNTAX: Unknown waypoint"}
{"instruction": "fly to the moon", "output": "INVALID_SYNTAX: Unknown waypoint"}

{"instruction": "fly underground to waypoint_a", "output": "INVALID_SYNTAX: Altitude constraint violation"}
{"instruction": "maintain altitude below ground level", "output": "INVALID_SYNTAX: Safety constraint violation"}
{"instruction": "fly below 0 meters", "output": "INVALID_SYNTAX: Altitude constraint violation"}
{"instruction": "descend to -5 meters", "output": "INVALID_SYNTAX: Altitude constraint violation"}

{"instruction": "find my keys", "output": "AMBIGUOUS_QUERY"}
{"instruction": "do a barrel roll", "output": "AMBIGUOUS_QUERY"}
{"instruction": "fly sideways", "output": "AMBIGUOUS_QUERY"}
{"instruction": "turn left 90 degrees", "output": "AMBIGUOUS_QUERY"}
{"instruction": "rotate around", "output": "AMBIGUOUS_QUERY"}
{"instruction": "go right", "output": "AMBIGUOUS_QUERY"}
{"instruction": "fly forward a bit", "output": "AMBIGUOUS_QUERY"}
{"instruction": "move up a little", "output": "AMBIGUOUS_QUERY"}
{"instruction": "wait for a while", "output": "AMBIGUOUS_QUERY"}

{"instruction": "continuously patrol all waypoints", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c)))"}
{"instruction": "infinite loop through waypoint_a, waypoint_b, waypoint_c", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c)))"}
{"instruction": "perpetual surveillance tour", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c)) & F(at(landing_pad)))"}

{"instruction": "eventually visit all waypoints but always return to base between visits", "output": "F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c)) & G((at(waypoint_a) | at(waypoint_b) | at(waypoint_c)) -> F(at(landing_pad)))"}
{"instruction": "visit each waypoint with base return between", "output": "F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c)) & G((at(waypoint_a) | at(waypoint_b) | at(waypoint_c)) -> F(at(landing_pad)))"}

{"instruction": "alternate between waypoint_a and waypoint_b every 30 seconds", "output": "G(at(waypoint_a) -> F(hover(30) & F(at(waypoint_b)))) & G(at(waypoint_b) -> F(hover(30) & F(at(waypoint_a))))"}
{"instruction": "30-second intervals between waypoint_a and waypoint_b", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b))) & G(at(waypoint_a) -> F(hover(30))) & G(at(waypoint_b) -> F(hover(30)))"}

{"instruction": "go to waypoint_a and hover there indefinitely", "output": "F(at(waypoint_a)) & G(F(at(waypoint_a)) -> stationary())"}
{"instruction": "reach waypoint_b and maintain position", "output": "F(at(waypoint_b)) & G(F(at(waypoint_b)) -> stationary())"}
{"instruction": "stay at waypoint_c forever", "output": "F(at(waypoint_c)) & G(at(waypoint_c))"}

{"instruction": "go to area_1 center and perform detailed scan", "output": "F(at(area_1)) & F(F(at(area_1)) & scan(area_1))"}
{"instruction": "systematic grid scan of area_1", "output": "F(scan(area_1))"}
{"instruction": "comprehensive area_1 survey", "output": "F(scan(area_1)) & G(near(area_1, 1.0))"}

{"instruction": "safe route to waypoint_a avoiding obstacles", "output": "F(at(waypoint_a)) & G(clear_of(obstacles))"}
{"instruction": "obstacle-free path to waypoint_b", "output": "F(at(waypoint_b)) & G(clear_of(obstacles))"}
{"instruction": "navigate to waypoint_c safely", "output": "F(at(waypoint_c)) & G(clear_of(obstacles))"}

{"instruction": "emergency protocol: land immediately", "output": "F(land())"}
{"instruction": "execute emergency landing procedure", "output": "F(land())"}
{"instruction": "immediate controlled descent", "output": "F(land())"}
{"instruction": "abort mission and return to base", "output": "F(at(landing_pad))"}

{"instruction": "if moving, always stay above 0.5 meters", "output": "G(moving() -> above(0.5))"}
{"instruction": "maintain altitude while in motion", "output": "G(moving() -> above(1.0))"}
{"instruction": "never descend below 1 meter when moving", "output": "G(moving() -> above(1.0))"}

{"instruction": "hover at current position for 20 seconds", "output": "hover(20)"}
{"instruction": "maintain current position for 10 seconds", "output": "hover(10)"}
{"instruction": "stationary hold for 30 seconds", "output": "hover(30)"}
{"instruction": "pause flight for 15 seconds", "output": "hover(15)"}

{"instruction": "scan area_1 from multiple angles", "output": "F(scan(area_1)) & F(near(area_1, 2.0))"}
{"instruction": "comprehensive area_1 inspection", "output": "F(scan(area_1)) & G(near(area_1, 1.5))"}
{"instruction": "detailed survey of area_1 perimeter", "output": "F(scan(area_1)) & G(near(area_1, 2.0))"}

{"instruction": "establish waypoint_a as base of operations", "output": "F(at(waypoint_a)) & G(F(at(waypoint_a)))"}
{"instruction": "use waypoint_b as staging area", "output": "F(at(waypoint_b)) & G(F(at(waypoint_b)))"}
{"instruction": "make waypoint_c the primary location", "output": "F(at(waypoint_c)) & G(F(at(waypoint_c)))"}

{"instruction": "go to the closest waypoint", "output": "AMBIGUOUS_QUERY"}
{"instruction": "visit the nearest location", "output": "AMBIGUOUS_QUERY"}
{"instruction": "fly to the farthest waypoint", "output": "AMBIGUOUS_QUERY"}
{"instruction": "head to the other waypoint", "output": "AMBIGUOUS_QUERY"}

{"instruction": "return to where we started", "output": "F(at(landing_pad))"}
{"instruction": "go back to the beginning", "output": "F(at(landing_pad))"}
{"instruction": "return to origin", "output": "F(at(landing_pad))"}
{"instruction": "go home", "output": "F(at(landing_pad))"}

{"instruction": "waypoint_a to waypoint_b direct route", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(waypoint_b)))"}
{"instruction": "straight line from waypoint_b to waypoint_c", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(waypoint_c)))"}
{"instruction": "direct flight waypoint_c to landing_pad", "output": "F(at(waypoint_c)) & F(F(at(waypoint_c)) & F(at(landing_pad)))"}

{"instruction": "spiral search pattern around waypoint_a", "output": "G(near(waypoint_a, 1.0)) & F(scan(area_1))"}
{"instruction": "circular reconnaissance around waypoint_b", "output": "G(near(waypoint_b, 2.0)) & F(scan(area_1))"}
{"instruction": "orbital survey of waypoint_c", "output": "G(near(waypoint_c, 1.5)) & F(scan(area_1))"}

{"instruction": "maintain safe distance from all obstacles", "output": "G(clear_of(obstacles))"}
{"instruction": "avoid all no-fly zones", "output": "G(in_bounds())"}
{"instruction": "respect all airspace restrictions", "output": "G(in_bounds())"}

{"instruction": "prioritize safety over mission completion", "output": "G(above(0.3)) & G(in_bounds()) & G(clear_of(obstacles))"}
{"instruction": "safety first protocol", "output": "G(above(0.3)) & G(in_bounds()) & G(clear_of(obstacles))"}
{"instruction": "execute with maximum safety margins", "output": "G(above(1.0)) & G(in_bounds()) & G(clear_of(obstacles))"}

{"instruction": "perform pre-flight safety check", "output": "G(above(0.3)) & G(in_bounds()) & G(clear_of(obstacles))"}
{"instruction": "verify all systems before mission", "output": "G(battery_level(20) -> F(at(landing_pad)))"}
{"instruction": "confirm operational parameters", "output": "G(above(0.3)) & G(in_bounds())"}

{"instruction": "adaptive route to waypoint_a based on conditions", "output": "F(at(waypoint_a)) & G(clear_of(obstacles))"}
{"instruction": "dynamic path planning to waypoint_b", "output": "F(at(waypoint_b)) & G(clear_of(obstacles))"}
{"instruction": "flexible approach to waypoint_c", "output": "F(at(waypoint_c)) & G(clear_of(obstacles))"}

{"instruction": "contingency plan: return if weather deteriorates", "output": "G(weather_bad() -> F(at(landing_pad)))"}
{"instruction": "abort on adverse conditions", "output": "G(emergency_condition() -> F(at(landing_pad)))"}
{"instruction": "weather-dependent mission execution", "output": "G(weather_bad() -> F(at(landing_pad)))"}

{"instruction": "multi-stage mission: waypoint_a, scan, waypoint_b, return", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(scan(area_1)) & F(F(scan(area_1)) & F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(landing_pad)))))"}
{"instruction": "complex sequence: waypoint_b, hover, scan, waypoint_c, return", "output": "F(at(waypoint_b)) & F(F(at(waypoint_b)) & hover(10) & F(F(hover(10)) & F(scan(area_1)) & F(F(scan(area_1)) & F(at(waypoint_c)) & F(F(at(waypoint_c)) & F(at(landing_pad))))))"}

{"instruction": "if at waypoint_a then scan area_1", "output": "G(at(waypoint_a) -> F(scan(area_1)))"}
{"instruction": "scan area_1 only when at waypoint_b", "output": "G(scan(area_1) -> at(waypoint_b))"}
{"instruction": "conditional scanning based on position", "output": "G(at(waypoint_c) -> F(scan(area_1)))"}

{"instruction": "until battery below 25%, continue patrol", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b))) U battery_level(25)"}
{"instruction": "patrol until low battery warning", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c))) U battery_level(20)"}
{"instruction": "mission continues until battery critical", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b))) U battery_level(15)"}

{"instruction": "maximum altitude 3 meters during mission", "output": "G(!above(3.0))"}
{"instruction": "never exceed 2.5 meter ceiling", "output": "G(!above(2.5))"}
{"instruction": "altitude limit 2 meters for safety", "output": "G(!above(2.0))"}
{"instruction": "stay below 3 meter altitude ceiling", "output": "G(!above(3.0))"}

{"instruction": "backward compatibility: fly to X", "output": "F(at(X))"}
{"instruction": "backward compatibility: go to Y then Z", "output": "F(at(Y)) & F(F(at(Y)) & F(at(Z)))"}
{"instruction": "legacy command: visit Z", "output": "F(at(Z))"}
{"instruction": "old format: navigate to X", "output": "F(at(X))"}

{"instruction": "precision landing at landing_pad", "output": "F(at(landing_pad)) & F(land())"}
{"instruction": "controlled descent to landing_pad", "output": "F(at(landing_pad)) & F(land())"}
{"instruction": "soft landing procedure", "output": "F(land())"}
{"instruction": "gentle touchdown at base", "output": "F(at(landing_pad)) & F(land())"}

{"instruction": "verify waypoint_a is reachable", "output": "F(at(waypoint_a))"}
{"instruction": "confirm access to waypoint_b", "output": "F(at(waypoint_b))"}
{"instruction": "test route to waypoint_c", "output": "F(at(waypoint_c))"}
{"instruction": "validate path to landing_pad", "output": "F(at(landing_pad))"}

{"instruction": "energy-efficient route to waypoint_a", "output": "F(at(waypoint_a))"}
{"instruction": "optimal path to waypoint_b", "output": "F(at(waypoint_b))"}
{"instruction": "shortest route to waypoint_c", "output": "F(at(waypoint_c))"}
{"instruction": "direct course to landing_pad", "output": "F(at(landing_pad))"}

{"instruction": "establish communication before proceeding", "output": "G(communication() -> F(at(waypoint_a)))"}
{"instruction": "maintain contact during mission", "output": "G(communication())"}
{"instruction": "verify signal strength before flight", "output": "G(communication())"}

{"instruction": "automated waypoint sequence", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(waypoint_c))))"}
{"instruction": "autonomous patrol mission", "output": "G(F(at(waypoint_a)) & F(at(waypoint_b)) & F(at(waypoint_c)))"}
{"instruction": "self-guided navigation sequence", "output": "F(at(waypoint_a)) & F(F(at(waypoint_a)) & F(at(waypoint_b)) & F(F(at(waypoint_b)) & F(at(waypoint_c))))"}

{"instruction": "real-time obstacle avoidance", "output": "G(clear_of(obstacles))"}
{"instruction": "dynamic obstacle detection", "output": "G(clear_of(obstacles))"}
{"instruction": "adaptive collision avoidance", "output": "G(clear_of(obstacles))"}

{"instruction": "mission abort sequence", "output": "F(at(landing_pad))"}
{"instruction": "emergency mission termination", "output": "F(emergency_return())"}
{"instruction": "immediate mission cancellation", "output": "F(at(landing_pad))"}

{"instruction": "system health monitoring during flight", "output": "G(battery_level(20) -> F(at(landing_pad)))"}
{"instruction": "continuous status assessment", "output": "G(battery_level(25) -> F(emergency_return()))"}
{"instruction": "automated health checks", "output": "G(battery_level(15) -> F(land()))"}